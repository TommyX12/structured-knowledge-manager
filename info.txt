@ see time manager note for more stuff

!!! unify terminologies like topics vs nodes

a standalone command-line based tool:
!!! integrate with vim, and make CLI intuitive and fast to use, extracting and saving etc.
// !!! prompt for setpath when old path becomes invalid (not a dir)
has a modifiable data base.
stores nodes in a graph.
automatic backup system.
standardized query output format for use in gui tools
you write a file that gets compiled into database (automatic linking).
    default append, and will not overwrite.

allow easy re-organization
    can merge two nodes (or add link to content in another node)

https://github.com/jsonpickle/jsonpickle might be useful for database.

when compiling:
    ask for all topic names in the document and show top 10 searches.
        skip entries that are exact match.
        search each part of a full namespace separately.
        able to find missing link (e.g. a::b::c but wrote a::c)
        able to use alias for each part
        prioritize to topics in current file
        
    also add ability to abort.
    also detect if two nodes have very similar names and ask if you want to auto correct.
    warn when appending to existing nodes. tell user to check for disambiguation.


able to escape with a \ at start of line so no special options is performed

!!! update lpp.vim syntax highlighting to suit this

can strength the database by adding more connection.

? automatic connection for stuff that are siblings but might have each other as prereq?

an interactive mode that can do queries such as view the graph structure like a file system.
    can fuzzy search the database.
    view content, parent, children of any node.
    query siblings, limited BFS propagation from node, explore topics, etc.

repurpose @: @ command, which executes command when interpreted. this usually modifies the topic that the commands are in.
    @ rename [new name]
        renames the topic to the new name.
        ? all rename commands are executed first? so then all other places use the new name.
        ? also rename all topics that has this in its namespace path
        
    @ overwrite
        mark the topic as having its content overwritten by whats written here.
    
    @ delete
        delete the topic. also delete all topics that are children (namespace tree), unless '@ delete self', then simply remove from part of children full name.
    
    @ alias [alias]
        add alias of this topic, useful when searching.
        
    @ file [file path]
    @ web [url]
        link to file or online resources

? allow rich content such as ms-word
    maybe contain file links that link to some files.
    this then do not support latex compiling, unless its an includable latex file.

can embed latex code.
    can also embed other code.

given a starting node, can extract out the parts you want to modify into a file (copying content from database), then you change and compile it back. (for example, generate something called MAT137 notes).
    default overwrite.
    when max traversal depth is reached, no longer mark overwrite, and omit content
    for cyclic reference, simply do not mark overwrite for the second referral, and omit content.
        
? use garbage collection reference model. label some nodes to be persistent, and some are not. any node that has not been set persistent will be destroyed when it has no parent.
    or just simply make top level nodes so as to organize things. force every-node to either connect to top level by some means, or be top level.

given a starting node, can generate latex document.
    or can generate many latex document and contain link that links.
    ? how to specify which copy of topic (when multiple occurs) to include and which to omit?

name matching shrinks word boundary, so "computer :: stack (memory segment)" is same as "computer    ::stack(memory    segment)"

actually manage the ? and !!! and @.

can also generate a bunch of files such that the entire database can be built from the ground up using only these files. can choose what to include, etc.

order of outgoing links within a node is preserved.

can specify max traversal depth
use graph algorithms, prefix-tree, etc.

also supports SQL style queries.
the modification file uses lpp note syntax and indent.
    if something is indented, this indicates a parent-child connection.
    can also have special macro that add a parent or remove a parent.
    ? maybe add a special type of link called pre-requisite links. what should those do and whats the difference between parent child relationship?
    renaming of nodes. maybe use an ID system.

local / enum nodes has only 1 parent, and will not have name clashing (local name-space). query use special search.
    . asdfasdfasd and 1. 2. etc
    . - asdf is no longer a local node, but an enum that refers to another global node
    can refer to as - python :: syntax.
    the restriction is that each segment between :: will need to be actual nodes.
    ? what if you remove connection from the parent to a local child?
    ? how to perform reorganization such that you can move a lot of local child to a new one to structure things?
    // ? do we introduce a command that refers to the old content of a node, so you can safely move them and maintain that?
    also, local links are automatic, meaning a :: b will always have a linked to b, even if not explicitly specified.

maybe even integrate machine learning clustering to re-organize.

maybe a namespace system similar to C#.
    specify file namespace (using) with :: music etc at top level lines.
    also specify such that all new nodes created are prepended with a namespace.

? adding a parent to a node with --:
    - python:
        -- list of programming languages

        . syntax:
            -- syntax :: examples
            def ...
            . conditionals:
                ...

        . type system:
            -- type system :: examples
            dynamic

        . latest version:
            3.6.x

    - programming language:
        - list of programming languages
        - syntax:
            syntax is defined as ....

    - type system:
        -- programming language
        type system is defined as ...

    after compilation:
        - python:
            . syntax:
                def ...
                . conditionals:
                    ...

            . type system:
                dynamic

            . latest version:
                3.6.x

        - programming language:
            - list of programming languages
            - syntax
            - type system

        - list of programming languages
            - python

        - syntax:
            syntax is defined as ....

            . examples:
                - python :: syntax

        - type system:
            type system is defined as ...

            . examples:
                - python :: type system

    when queried by programming language:
        - programming language:
            @ overwrite
            - list of programming languages
                @ overwrite
                - python
                    @ overwrite
                    . syntax:
                        @ overwrite
                        def ...
                        . conditionals:

                    . type system:
                        @ overwrite
                        dynamic

                    . latest version:
                        @ overwrite
                        3.6.x

            - syntax
                @ overwrite
                syntax is defined as ....

                . examples:
                    @ overwrite
                    - python :: syntax

            - type system
                @ overwrite
                type system is defined as ...

                . examples:
                    @ overwrite
                    - python :: type system

    
!!! maybe build a GUI that is easy to use.

!!! after this is kinda operational, move my knowledges into it. make sure to regularly backup.
